// Generated by CoffeeScript 1.3.1
(function() {

  module.exports = {
    engines: {},
    engine: function(extension) {
      var _base;
      extension = extension.replace(/^\./, '');
      return (_base = this.engines)[extension] || (_base[extension] = (function() {
        switch (extension) {
          case "styl":
          case "stylus":
            return "stylus";
          case "jade":
            return "jade";
          case "eco":
            return "eco";
          case "haml":
            return "haml";
          case "hamlc":
            return "hamlcoffee";
          case "ejs":
            return "ejs";
          case "coffee":
          case "coffeescript":
          case "coffee-script":
            return "coffee";
          case "less":
            return "less";
          case "mu":
          case "mustache":
            return "mustache";
          case "hbs":
          case "handlebars":
            return "handlebars";
          case "md":
          case "mkd":
          case "markdown":
          case "mdown":
            return "markdown";
        }
      })());
    },
    enginesFor: function(path) {
      var engine, engines, extension, extensions, _i, _len;
      engines = [];
      extensions = path.split("/");
      extensions = extensions[extensions.length - 1];
      extensions = extensions.split(".").slice(1);
      for (_i = 0, _len = extensions.length; _i < _len; _i++) {
        extension = extensions[_i];
        engine = this.engine(extension);
        if (engine) {
          engines.push(engine);
        }
      }
      return engines;
    },
    render: function(options, callback) {
      var engines, iterate, path, string,
        _this = this;
      path = options.path;
      string = options.string || require('fs').readFileSync(path, 'utf-8');
      engines = options.engines || this.enginesFor(path);
      iterate = function(engine, next) {
        return _this[engine](string, options, function(error, output) {
          if (error) {
            return next(error);
          } else {
            string = output;
            return next();
          }
        });
      };
      return this._async(engines, iterate, function(error) {
        return callback.call(_this, error, string);
      });
    },
    compile: function(options, callback) {
      var engine, result, template;
      engine = require(options.engine === 'haml' ? 'hamljs' : options.engine);
      template = options.template || options.content;
      result = engine.compile(template);
      return result;
    },
    stylus: function(content, options, callback) {
      var engine, path, preprocessor, result,
        _this = this;
      result = "";
      path = options.path;
      preprocessor = options.preprocessor || this.stylus.preprocessor;
      if (preprocessor) {
        content = preprocessor.call(this, content, options);
      }
      engine = require('stylus');
      engine.render(content, options, function(error, data) {
        result = data;
        if (error && path) {
          error.message = error.message.replace(/\n$/, ", " + path + "\n");
        }
        if (callback) {
          return callback.call(_this, error, result);
        }
      });
      return result;
    },
    jade: function(content, options, callback) {
      var path, preprocessor, result,
        _this = this;
      result = "";
      path = options.path;
      preprocessor = options.preprocessor || this.jade.preprocessor;
      if (preprocessor) {
        content = preprocessor.call(this, content, options);
      }
      require("jade").render(content, options, function(error, data) {
        result = data;
        if (error && path) {
          error.message += ", " + path;
        }
        if (callback) {
          return callback.call(_this, error, result);
        }
      });
      return result;
    },
    haml: function(content, options, callback) {
      var result;
      result = require('hamljs').render(content, options || {});
      if (callback) {
        callback.call(this, null, result);
      }
      return result;
    },
    hamlcoffee: function(content, options, callback) {
      var result;
      result = require('haml-coffee').compile(content, options || {})(options.locals);
      if (callback) {
        callback.call(this, null, result);
      }
      return result;
    },
    ejs: function(content, options, callback) {
      var error, result;
      result = "";
      error = null;
      try {
        result = require("ejs").render(content, options);
      } catch (e) {
        error = e;
        result = null;
      }
      if (callback) {
        callback.call(this, error, result);
      }
      return result;
    },
    eco: function(content, options, callback) {
      var result;
      result = require("eco").render(content, options.locals);
      if (callback) {
        callback.call(this, null, result);
      }
      return result;
    },
    coffee: function(content, options, callback) {
      var error, path, preprocessor, result;
      result = "";
      path = options.path;
      if (!options.hasOwnProperty("bare")) {
        options.bare = true;
      }
      preprocessor = options.preprocessor || this.coffee.preprocessor;
      if (preprocessor) {
        content = preprocessor.call(this, content, options);
      }
      try {
        result = require("coffee-script").compile(content, options);
      } catch (e) {
        result = null;
        error = e;
        if (path) {
          error.message += ", " + path;
        }
      }
      if (callback) {
        callback.call(this, error, result);
      }
      return result;
    },
    coffeekup: function(content, options, callback) {
      var result;
      result = require("coffeekup").render(content, options);
      if (callback) {
        callback.call(this, null, result);
      }
      return result;
    },
    less: function(content, options, callback) {
      var engine, parser, path, result,
        _this = this;
      result = "";
      path = options.path;
      options.filename = path;
      options.paths || (options.paths = []);
      options.paths = ["."].concat(options.paths);
      engine = require("less");
      parser = new engine.Parser(options);
      try {
        parser.parse(content, function(error, tree) {
          var message;
          if (error) {
            if (path) {
              error.message += ", " + path;
            }
          } else {
            try {
              result = tree.toCSS();
            } catch (e) {
              error = e;
            }
          }
          if (error) {
            message = error.message + ", " + path;
          }
          if (callback) {
            return callback.call(_this, message, result);
          }
        });
      } catch (error) {
        callback.call(this, error.message += ", " + path, "");
      }
      return result;
    },
    mustache: function(content, options, callback) {
      var error, path, preprocessor, result;
      path = options.path;
      error = null;
      preprocessor = options.preprocessor || this.constructor.preprocessor;
      if (preprocessor) {
        content = preprocessor.call(this, content, options);
      }
      try {
        result = require("mustache").to_html(content, options.locals);
      } catch (e) {
        error = e;
        result = null;
        if (path) {
          error.message += ", " + path;
        }
      }
      if (callback) {
        callback.call(this, error, result);
      }
      return result;
    },
    handlebars: function(content, options, callback) {
      var error, result;
      error = null;
      try {
        result = require("handlebars").compile(content)(options.locals || {});
      } catch (e) {
        error = e;
      }
      if (callback) {
        return callback.call(this, error, result);
      }
    },
    markdown: function(content, options, callback) {
      var error, preprocessor, result;
      error = null;
      preprocessor = options.preprocessor || this.constructor.preprocessor;
      if (preprocessor) {
        content = preprocessor.call(this, content, options);
      }
      try {
        result = require("markdown").parse(content);
      } catch (e) {
        error = e;
      }
      if (callback) {
        callback.call(this, error, result);
      }
      return result;
    },
    yui: function(content, options, callback) {
      var error, path, result;
      path = options.path;
      error = null;
      try {
        result = require("./vendor/cssmin").cssmin(content);
      } catch (e) {
        error = e;
        if (path) {
          error.message += ", " + path;
        }
      }
      if (callback) {
        callback.call(this, error, result);
      }
      return result;
    },
    cleanCSS: function(content, options, callback) {
      var error, path, result;
      path = options.path;
      error = null;
      try {
        result = require("clean-css").process(content);
      } catch (e) {
        error = e;
        if (path) {
          error.message += ", " + path;
        }
      }
      if (callback) {
        callback.call(this, error, result);
      }
      return result;
    },
    uglifyjs: function(content, options, callback) {
      var ast, compressor, error, parser, path, result;
      path = options.path;
      error = null;
      parser = require("uglify-js").parser;
      compressor = require("uglify-js").uglify;
      try {
        ast = parser.parse(content);
        ast = compressor.ast_mangle(ast);
        ast = compressor.ast_squeeze(ast);
        result = compressor.gen_code(ast);
      } catch (e) {
        error = e;
        if (path) {
          error.message += ", " + path;
        }
      }
      if (callback) {
        callback.call(this, error, result);
      }
      return result;
    },
    _async: function(array, iterator, callback) {
      var completed, iterate;
      if (!array.length) {
        return callback();
      }
      completed = 0;
      iterate = function() {
        return iterator(array[completed], function(error) {
          if (error) {
            callback(error);
            return callback = function() {};
          } else {
            completed += 1;
            if (completed === array.length) {
              return callback();
            } else {
              return iterate();
            }
          }
        });
      };
      return iterate();
    }
  };

}).call(this);
